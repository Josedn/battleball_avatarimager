<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Battleball</title>
  <style type="text/css">
  body
  {
    margin: 0 auto;
    background-color: #00aaaa;
    color: #dddddd;
  }
  canvas
  {
    position: absolute;
    width: 100%;
    position: absolute;
    width: 100%;
    height: 100%;
  }
  </style>
  <script>
  AvatarImager.LOCAL_RESOURCES_URL = "./resource/";

  function AvatarSprite(lib, resourceName, isFlip, color) {
    this.lib = lib;
    this.resourceName = resourceName;
    this.isFlip = isFlip;
    this.color = color;
    this.ready = false;
  };

  AvatarSprite.prototype.downloadAsync = function() {
    var img = new Image();
    var d = new Promise(function (resolve, reject) {
      img.onload = function () {
        this.resource = img;
        //console.log("downloaded " + this.lib + " -> " + this.resourceName);
        resolve(img);
      }.bind(this);

      img.onerror = function () {
        console.log("NOT DOWNLOADED "  + this.lib + " -> " + this.resourceName);
        reject('Could not load image: ' + src);
      };
    }.bind(this));

    img.src = AvatarImager.LOCAL_RESOURCES_URL + this.lib + "/" + this.lib + "_" + this.resourceName + ".png";
    return d;
  };

  function AvatarImage(figure, direction, headDirection, action, gesture, frame, isHeadOnly, scale) {
    this.isLarge = false;
    this.isSmall = false;
    this.rectWidth = 64;
    this.rectHeight = 110;
    switch (scale) {
      case "l":
      this.isLarge = true;
      this.rectWidth = 128;
      this.rectHeight = 220;
      break;
      case "s":
      this.isSmall = true;
      this.rectWidth = 32;
      this.rectHeight = 55;
      break;
      case "n":
      default:
      break;
    }
    this.isHeadOnly = isHeadOnly === true;
    this.figure = [];
    figure.split('.').forEach(part => {
      var data = part.split('-');
      var figurePart = {"type" : data[0], "id" : data[1], "colors" : [ data[2] ]};
      if (data[3] != null) {
        figurePart.colors.push(data[3]);
      }
      this.figure.push(figurePart);
    });

    this.frame = Array.isArray(frame) ? frame : [ frame ];
    this.drawAction = {"body" : "std", "wlk" : false, "sit" : false, "gesture" : false, "eye" : false, "speak" : false, "itemRight": false, "handRight" : false, "handLeft": false, "swm" : false};
    this.handItem = false;
    this.drawOrder = "std";
    this.ok = false;
    this.gesture = gesture;
    this.direction = this.isValidDirection(direction) ? direction : 0;
    this.headDirection = this.isValidDirection(headDirection) ? headDirection : 0;

    switch(this.gesture) {
      case "spk":
      this.drawAction['speak'] = this.gesture;
      break;
      case "eyb":
      this.drawAction['eye'] = this.gesture;
      break;
      case "":
      this.drawAction['gesture'] = "std";
      break;
      default:
      this.drawAction['gesture'] = this.gesture;
      break;
    }

    this.action = Array.isArray(action) ? action : [ action ];
    this.action.forEach(value => {
      var actionParams = value.split('=');
      switch (actionParams[0]) {
        case "wlk":
        case "sit":
        this.drawAction[actionParams[0]] = actionParams[0];
        break;

        case "lay":
        this.drawAction['body']	= actionParams[0];
        this.drawAction['eye'] = actionParams[0];

        var temp = this.rectWidth;
        this.rectWidth = this.rectHeight;
        this.rectHeight = temp;

        switch (this.gesture) {
          case "spk":
          this.drawAction['speak'] = "lsp";
          this.frame['lsp'] = this.frame[this.gesture];
          break;

          case "eyb":
          this.drawAction['eye'] = "ley";
          break;

          case "std":
          this.drawAction['gesture'] = actionParams[0];
          break;

          default:
          this.drawAction['gesture'] = "l" + this.gesture.substr(0, 2);
          break;
        }
        break;

        case "wav":
        this.drawAction['handLeft'] = actionParams[0];
        break;

        case "crr":
        case "drk":
        this.drawAction['handRight'] = actionParams[0];
        this.drawAction['itemRight'] = actionParams[0];
        this.handItem = actionParams[1];
        break;

        case "swm":
        this.drawAction[actionParams[0]] = actionParams[0];
        if (this.gesture == "spk") {
          this.drawAction['speak'] = "sws";
        }
        break;

        case "":
        this.drawAction['body'] = "std";
        break;

        default:
        this.drawAction['body'] = actionParams[0];
        break;
      }
    });

    if (this.drawAction['sit'] == "sit") {
      if (this.direction >= 2 && this.direction <= 4) {
        this.drawOrder = "sit";
        if (this.drawAction['handRight'] == "drk" && this.direction >= 2 && this.direction <= 3) {
          this.drawOrder += ".rh-up";
        } else if (this.drawAction['handLeft'] && this.direction == 4) {
          this.drawOrder += ".lh-up";
        }
      }
    } else if (this.drawAction['body'] == "lay") {
      this.drawOrder = "lay";
    } else if (this.drawAction['handRight'] == "drk" && this.direction >= 0 && this.direction <= 3) {
      this.drawOrder = "rh-up";
    } else if (this.drawAction['handLeft'] && this.direction >= 4 && this.direction <= 6) {
      this.drawOrder = "lh-up";
    }

    this.ok = true;
  };

  AvatarImage.prototype.isValidDirection = function(direction) {
    return (Number.isInteger(direction) && direction >= 0 && direction <= 7);
  };

  function AvatarImager() {
    this.ready = false;
    this.offsets = {};
  };

  AvatarImager.prototype.initialize = function(onReady) {
    var p = this.loadFiles();
    Promise.all(p).then(function (loaded) {
      this.ready = true;
      if (onReady != null) {
        onReady();
      }
    }.bind(this));
  };

  AvatarImager.prototype.getPartUniqueName = function(type, partId) {
    var uniqueName = this.figuremap[type][partId];
    if (uniqueName == null && type == "hrb") {
      uniqueName = this.figuremap["hr"][partId];
    }
    if (uniqueName == null) {
      uniqueName = this.figuremap[type][1];
    }
    if (uniqueName == null) {
      uniqueName = this.figuremap[type][0];
    }
    return uniqueName;
  };

  AvatarImager.prototype.getFrameNumber = function(type, action, frame) {
    return 0;
  };

  AvatarImager.prototype.getActivePartSet = function(partSet) {
    //var ret = [];
    var activeParts = this.partsets['activePartSet'][partSet]['activePart'];
    if (activeParts == null || activeParts.length == 0) {
      return false;
    }
    return activeParts;
    //var partSetData = this.partsets['partSet'];
    //activeParts.forEach(type => {
    //ret.push(type);
    //});
    //return ret;
  };

  AvatarImager.prototype.buildResourceName = function(action, type, isSmall, partId, direction, frame, uniqueName) {
    var resourceName = isSmall ? "sh" : "h";
    resourceName += "_";
    resourceName += action;
    resourceName += "_";
    resourceName += type;
    resourceName += "_";
    resourceName += partId;
    resourceName += "_";
    resourceName += direction;
    resourceName += "_";
    resourceName += frame;
    return resourceName;
  };

  AvatarImager.prototype.getPartResource = function(uniqueName, action, type, isSmall, partId, direction, color) {
    var frame = this.getFrameNumber(type, action, null);
    var isFlip = false;
    var resDirection = direction;

    //file_exists? ======= true

    //r63 self alias
    if(type == "hd" && isSmall) partId = 1;
    if(type == "ey" && action == "std" && partId == 1 && direction == 3) action = "sml";
    if(type == "fa" && action == "std" && partId == 2 && (direction == 2 || direction == 4)) resDirection = 1;
    if(type == "he" && action == "std" && partId == 1) {
      if(direction == 2) {
        resDirection = 0;
      }
      if(direction >= 4 && direction <= 6) {
        return false;
      }
    }
    if(type == "he" && action == "std" && partId == 8) resDirection = direction % 2 == 0 ? 1 : resDirection;
    if(type == "he" && action == "std" && (partId == 2131 || partId == 2132) && (direction >= 2 && direction <= 6)) resDirection = 1;
    if(type == "ha" && action == "std" && partId == 2518) resDirection = direction % 2 == 0 ? 2 : 1;
    if(type == "ha" && action == "std" && partId == 2519) resDirection = direction % 2 == 0 ? 2 : 3;
    if(type == "ha" && action == "std" && partId == 2588) resDirection = 7;
    if(type == "ha" && action == "std" && partId == 2589) resDirection = 3;

    var resourceName = this.buildResourceName(action, type, isSmall, partId, resDirection, frame, uniqueName);
    var resource = new AvatarSprite(uniqueName, resourceName, false, color);
    return resource;
  };

  AvatarImager.prototype.getDrawOrder = function(action, direction) {
    var drawOrder = this.draworder[action][direction];
    if (drawOrder == null || drawOrder.length == 0) {
      return false;
    }
    return drawOrder;
  };

  AvatarImager.prototype.getColorByPaletteId = function(paletteId, colorId) {
    if (this.figuredata['palette'][paletteId] != null && this.figuredata['palette'][paletteId][colorId] != null && this.figuredata['palette'][paletteId][colorId]['color'] != null) {
      return this.figuredata['palette'][paletteId][colorId]['color'];
    }
    return null;
  };

  AvatarImager.prototype.getPartColor = function(figure) {
    var parts = {};
    var partSet = this.figuredata['settype'][figure.type];
    if (partSet['set'][figure.id]['part'] != null) {
      partSet['set'][figure.id]['part'].forEach(part => {
        console.log(figure);
        console.log(part);
        console.log("paletteid: " + partSet.paletteid + " colors: " + figure.colors[part.colorindex - 1]);
        var element = {"index" : part.index, "id" : part.id, "colorable" : part.colorable };
        if (part.colorable) {
          element.color = this.getColorByPaletteId(partSet.paletteid, figure.colors[part.colorindex - 1]);
        }
        if (parts[part.type] == null) {
          parts[part.type] = [element];
        } else {
          parts[part.type].push(element);
        }


      });
    }
    return parts;
  };

  AvatarImager.prototype.generate = function(avatarImage, canvasCallback) {
    if (!avatarImage.ok) {
      return null;
    }
    var tempCanvas = document.createElement('canvas');
    var tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = avatarImage.rectWidth;
    tempCanvas.height = avatarImage.rectHeight;
    tempCtx.fillStyle = "#ffffff";
    tempCtx.fillRect(0, 0, avatarImage.rectWidth, avatarImage.rectHeight);

    var activeParts = {};
    activeParts.rect = this.getActivePartSet(this.isHeadOnly ? "head" : "figure");
    activeParts.head = this.getActivePartSet("head");
    activeParts.eye = this.getActivePartSet("eye");
    activeParts.gesture = this.getActivePartSet("gesture");
    activeParts.speak = this.getActivePartSet("speak");
    activeParts.walk	= this.getActivePartSet("walk");
    activeParts.sit = this.getActivePartSet("sit");
    activeParts.itemRight = this.getActivePartSet("itemRight");
    activeParts.handRight = this.getActivePartSet("handRight");
    activeParts.handLeft = this.getActivePartSet("handLeft");
    activeParts.swim = this.getActivePartSet("swim");

    var drawParts = this.getDrawOrder(avatarImage.drawOrder, avatarImage.direction);
    if (drawParts === false) {
      drawParts = this.getDrawOrder("std", avatarImage.direction);
    }

    var setParts = [];
    avatarImage.figure.forEach(parSet => {
      setParts = Object.assign(setParts, this.getPartColor(parSet));
    });

    if (avatarImage.handItem !== false) {
      setParts["ri"] = [ {"index" : 0, "id" : avatarImage.handItem} ];
    }

    var drawCount = 0;

    var chunks = [];
    var offsetsPromises = [];

    drawParts.forEach(type => {
      var drawableParts = setParts[type];
      if (drawableParts != null) {
        for (drawablePart of drawableParts) {
          var uniqueName = this.getPartUniqueName(type, drawablePart["id"]);
          if (uniqueName != null) {
            console.log(type + " -> " + drawablePart["id"] + " -> " + uniqueName);

            if (this.offsets[uniqueName] == null) {
              offsetsPromises.push(this.downloadOffsetAsync(uniqueName));
            }
            //TODO: check eyes
            var color = drawablePart.colorable && type != "ey" ? drawablePart.color : null;
            var drawPartChunk = this.getPartResource(uniqueName, avatarImage.action, type, avatarImage.isSmall, drawablePart["id"], avatarImage.direction, color);
            chunks.push(drawPartChunk);
            drawCount++;
          }
        }
      }
    });

    Promise.all(offsetsPromises).then(function() {
      //console.log("offsets ok!");

      var chunksPromises = [];

      for (chunk of chunks) {
        //console.log(chunk);
        if (this.offsets[chunk.lib] != null && this.offsets[chunk.lib][chunk.resourceName] != null) {
          if (this.offsets[chunk.lib][chunk.resourceName].flipped) {

          } else {
            chunksPromises.push(chunk.downloadAsync());
          }
        } else {
          //console.log("wrong chunk??1");
        }
      }

      Promise.all(chunksPromises).catch(function(a) {
      }).then(function () {
        console.log("drawing...");

        var off= 0;
        for (chunk of chunks) {
          if (this.offsets[chunk.lib] != null && this.offsets[chunk.lib][chunk.resourceName] != null) {
            console.log(chunk);
            if (chunk.resource != null) {
              var posX = -this.offsets[chunk.lib][chunk.resourceName].x;
              var posY = (avatarImage.rectHeight / 2) - this.offsets[chunk.lib][chunk.resourceName].y + avatarImage.rectHeight / 2.5;
              console.log("x: " + posX + " - y: " + posY + " - color: " + chunk.color );

              var img = chunk.resource;
              if (chunk.color != null) {
                img = this.tintSprite(img, chunk.color);
              }
              tempCtx.drawImage(img, posX, posY);
              off += 20;
            } else {
              console.log("Missing resource");
            }
          }
        }

        canvasCallback(tempCanvas);
      }.bind(this));
    }.bind(this));
  };

  AvatarImager.prototype.hex2rgb = function(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  AvatarImager.prototype.tintSprite = function(img, color) {
    var element = document.createElement('canvas');
    var c = element.getContext("2d");

    var rgb = this.hex2rgb(color);

    var width = img.width;
    var height = img.height;

    element.width = width;
    element.height = height;

    c.drawImage(img, 0, 0);
    var imageData = c.getImageData(0, 0, width, height);
    for (var y = 0; y < height; y++) {
      var inpos = y * width * 4;
      for (var x = 0; x < width; x++) {
        var pr = imageData.data[inpos++];
        var pg = imageData.data[inpos++];
        var pb = imageData.data[inpos++];
        var pa = imageData.data[inpos++];
        if (pa != 0) {
          imageData.data[inpos - 2] = Math.round(rgb.b * imageData.data[inpos - 2] / 255); //B
          imageData.data[inpos - 3] = Math.round(rgb.g * imageData.data[inpos - 3] / 255); //G
          imageData.data[inpos - 4] = Math.round(rgb.r * imageData.data[inpos - 4] / 255); //R
        }
      }
    }
    c.putImageData(imageData, 0, 0);
    return element;
  }

  AvatarImager.prototype.downloadJsonAsync = function(key, url) {
    return new Promise(function (resolve, reject) {
      var r = new XMLHttpRequest();
      r.open("GET", url, true);
      r.onreadystatechange = function () {
        if (r.readyState != 4 || r.status != 200) {
          if (r.status == 404) {
            reject("Error downloading " + url);
          }
          return;
        }
        this[key] = JSON.parse(r.responseText);
        resolve();
      }.bind(this);
      r.send();
    }.bind(this));
  };

  AvatarImager.prototype.downloadOffsetAsync = function(uniqueName) {
    this.offsets[uniqueName] = {};
    return new Promise(function (resolve, reject) {
      var r = new XMLHttpRequest();
      r.open("GET", AvatarImager.LOCAL_RESOURCES_URL + uniqueName + "/offset.json", true);
      r.onreadystatechange = function () {
        if (r.readyState != 4 || r.status != 200) {
          if (r.status == 404) {
            reject("Error downloading " + url);
          }
          return;
        }
        this.offsets[uniqueName] = JSON.parse(r.responseText);
        resolve();
      }.bind(this);
      r.send();
    }.bind(this));
  };

  AvatarImager.prototype.loadFiles = function() {
    return [
      this.downloadJsonAsync("figuremap", AvatarImager.LOCAL_RESOURCES_URL + "map.json"),
      this.downloadJsonAsync("figuredata", AvatarImager.LOCAL_RESOURCES_URL + "figuredata.json"),
      this.downloadJsonAsync("partsets", AvatarImager.LOCAL_RESOURCES_URL + "partsets.json"),
      this.downloadJsonAsync("draworder", AvatarImager.LOCAL_RESOURCES_URL + "draworder.json")
    ];
  };

  var Game = {};
  window.onload = function () {
    Game.avatar = new AvatarImage("hr-3162-1407.sh-300-110.hd-190-1390.lg-275-110.ch-215-85.ha-3140-110", 2, 2, "std", "std", 0, false, "n");
    Game.avatarImager = new AvatarImager();

    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;


    Game.avatarImager.initialize(function() {
      console.log("Ready to draw!");

      Game.avatarImager.generate(Game.avatar, function(img) {
        console.log("Drawing done");
        ctx.drawImage(img, 10, 10);
      });
    });

    //ctx.drawImage(image, 100, 100);

  };

  </script>

</head>
<body>
  <canvas id="game"></canvas>
</body>
</html>
